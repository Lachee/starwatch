<html>
<head>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css" />

        <script
            src="https://code.jquery.com/jquery-3.4.1.min.js"
            integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
            crossorigin="anonymous"></script>
			
<script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js"></script>
<script src="js/sbname.js"></script>
<script src="js/l.ellipse.min.js"></script>
<style>
	#map {
		width: 100%;
		height: 100%;
		background: #120115bf;
	}
	
	body{
		padding: 0;
		margin: 0;
		background: url('map/space-small.jpg');
	}
	
	.control {
		position: absolute;
		top: 12px;
		left: 60px;
	}

	.control input {
		border-radius: 3px;
		border: 1px solid black;
		padding: 4px;
	}

	.leaflet-popup-content-wrapper, .leaflet-popup-tip { background: #353535; color: #dedede }

</style>
</head>

<body>
	<div id="map"></div>
	<div class="control">
		<input id="x" type="text" value="17" />
		<input id="y" type="text" value="17" />
		<button onclick="flyToInput();">Fly</button>
	</div>
</body>

<script>
	var scale = 0.5;
	var minimumOrbit = 0.1;
	var orbitScale = 0.1;
	var moonOrbitModifier = 0.25;
	var logScaling = true;
	
	
	
	
	//END CONFIG
//https://github.com/jdfergason/Leaflet.Ellipse/blob/master/l.ellipse.js
//https://leafletjs.com/examples/crs-simple/crs-simple.html
//https://github.com/Leaflet/Leaflet.markercluster#options
	if (!logScaling) 
	{
		scale /= 10;
		minimumOrbit /= 10;
		orbitScale /= 10;
		moonOrbitModifier /= 10;
	}
		
	function s(v) {  return !logScaling ? v : (v < 0 ? -Math.log10(Math.abs(v)) : Math.log10(v)); }
	
	
	var yx = L.latLng;
	var xy = function(x, y) 
	{
		let x2 = x;
		let y2 = y;
		if (L.Util.isArray(x)) 
		{
			// We are doing xy([x, y]);    
			x2 = x[0];
			y2 = x[1];
		}
		
		//Apply scales
		x2 = s(x2) * scale;
		y2 = s(y2) * scale;
		
		//Return the response
		return yx(y2, x2);  // When doing xy(x, y);
	};

	var rcircle = function(x, y, r)
	{
		var angle = Math.random()*Math.PI*2
		return [ x + (Math.cos(angle) * r), y + (Math.sin(angle) * r)]
	}

	var StarIcon = L.Icon.extend({
		options: {
			shadowUrl: '',
			iconSize:     [26, 26],
			iconAnchor:   [13, 13],
			shadowSize:   [13, 13],
			shadowAnchor: [5, 5],
			popupAnchor:  [0, 0]
		}
	});
	var PlanetIcon = L.Icon.extend({
		options: {
			shadowUrl: '',
			iconSize:     [16, 16],
			iconAnchor:   [8, 8],
			shadowSize:   [13, 13],
			shadowAnchor: [5, 5],
			popupAnchor:  [0, 0]
		}
	});
	var blueStarIcon = new StarIcon({iconUrl: 'map/star13pxLightBlue.gif'});
	var giantStarIcon = new StarIcon({iconUrl: 'map/star13pxLightBlue-scaled.gif'});
	var largePlanetIcon = new PlanetIcon({iconUrl: 'map/planet_large_34px.png'});
	var smallPlanetIcon = new PlanetIcon({iconUrl: 'map/planet_small_34px.png'});

	var showingState = 0;
	var orbitLayer = new L.FeatureGroup();
	var systemLayer = new L.FeatureGroup();
	var starLayer = new L.FeatureGroup();
	var map = L.map('map', {
		crs: L.CRS.Simple,
		minZoom: -3
	});

	L.LatLng.prototype.distanceToCRSSimple = function(other) {
		other = L.latLng(other);
		var lngS = 0, latS = 0;

		lngS = other.lng - this.lng;
		lngS = lngS * lngS;

		latS = other.lat - this.lat;
		latS = latS * latS;

		return Math.sqrt(lngS + latS);
	};

	map.on('zoomend', function(ev){
	  if (map.getZoom() < 13) 
	  {
		//if (showingState >= 0)
		{
			console.log("Showing Stars");
			map.removeLayer(orbitLayer);
            map.removeLayer(systemLayer);
			showingState = -1;
		}
	  } 
	  else
	  {
		//if (showingState <= 0)
		{
			console.log("Showing Systems");
			map.addLayer(orbitLayer);
			map.addLayer(systemLayer);
			showingState = 1;
		}
	  }
	});

	//var bounds = [[-26.5,-25], [1021.5,1023]];
	var bounds = [[0,0], [1000,1000]];
	map.setView([-0.35, 0.42], 10);
	//var image = L.imageOverlay('uqm_map_full.png', bounds).addTo(map);

	
	function getPopup(world)
	{
		return "<b>" + formatStarboundTags(world.Details.Name) + "</b><hr>" + world.Details.Description + "<br>" + world.Details.TerrainType + " (" + world.Details.TerrainSize + ")<br>" + world.Details.PrimaryBiome + "<br>" + world.Whereami;
	}

	function getSystemPopup(x, y, isLocalView)
	{
		let coord = x + ", " + y;
		let txt = "System " + coord;
		if (!isLocalView)
			txt += "<br><a href='#" + coord + "' onclick='flyToCoordinate(map, " + coord + ");'>Fly To</a>";
		return txt;
	}

	getWorlds(map);
	function getWorlds(map)
	{
		const Http = new XMLHttpRequest();
		const url='https://sb.ilovebacons.com:4242/api/world/search?systems';
		Http.open("GET", url);
		Http.send();

		Http.onreadystatechange = (e) => {
			if (Http.readyState == 4 && Http.status == 200)
			{
				var response = JSON.parse(Http.responseText);
				console.log(response.Response);
				for(var key in response.Response)
				{
					var scoord = null;
					var planets = [];
					for(var i in response.Response[key]) 
					{
						var world = response.Response[key][i];
						
						if (scoord == null)
							scoord = xy(world.X, world.Y);
						
						var radius = minimumOrbit + world.Planet * orbitScale;
						var centerX = world.X;
						var centerY = world.Y;
						
							
						if (world.IsMoon)
						{
							//Generate coordinates in advance for ourself
							if (planets[world.Planet] == null)
								planets[world.Planet] = rcircle(centerX, centerY, radius);
							
							//Base our center point of the planet
							centerX = planets[world.Planet][0];
							centerY = planets[world.Planet][1];	
							
							//Recalculate the radius
							radius = (minimumOrbit + world.Moon * orbitScale) * moonOrbitModifier;
						}
						
						//Generate coordinates
						var pos = rcircle(centerX, centerY, radius);
						
						//Update our position so any moons can use it
						if (!world.IsMoon)
							planets[world.Planet] = pos;
						
						//Calculate our laglong
						var coord = xy(pos[0], pos[1]);
						
						//Create our marker
						var marker = L.marker(coord, {icon: world.Details.TerrainSize == 'large' ? largePlanetIcon : smallPlanetIcon}).bindPopup(getPopup(world));
						
						//Create our circle
						var centerCoord = xy(centerX, centerY);
						
						//var dx = map.distance(xy(centerX, 0), xy(pos[0], 0)) * (1.113 * 100000);		
						//var dy = map.distance(xy(0, centerY), xy(0, pos[1])) * (1.113 * 100000);		
						var dist = map.distance(centerCoord, coord) * (1.113 * 100000);						
						var ecllipse = L.ellipse(centerCoord, [dist, dist], 90, {
							stroke: true,
							weight: 1,
							fill: false,
							color: '#e3e3e33a',
							bubblingMouseEvents: false
						});
						systemLayer.addLayer(marker);
						orbitLayer.addLayer(ecllipse);
					}
						
					if (scoord != null) {
						systemLayer.addLayer(L.marker(scoord, { icon: blueStarIcon }).bindPopup(getSystemPopup(world.X, world.Y, true)));
						starLayer.addLayer(L.marker(scoord, { icon: giantStarIcon }).bindPopup(getSystemPopup(world.X, world.Y, false)));
					}
				}
				
				map.addLayer(starLayer);
				map.flyTo([-0.35, 0.42], 10);
			}
			
		}
	}
	
	function locatePlayer(map, connection)
	{
		const Http = new XMLHttpRequest();
		const url='https://sb.ilovebacons.com:4242/api/player/' + connection + '?enforce=true';
		Http.open("GET", url);
		Http.send();

		Http.onreadystatechange = (e) => {
			if (Http.readyState == 4 && Http.status == 200)
			{
				var response = JSON.parse(Http.responseText);
				console.log(response.Response);
				flyToCelestial(map, response.Response.Location);
			}
		}
	}
	
	function flyToCelestial(map, celestial)
	{
		const Http = new XMLHttpRequest();
		const url='https://sb.ilovebacons.com:4242/api/world/' + celestial;
		Http.open("GET", url);
		Http.send();

		Http.onreadystatechange = (e) => {
			if (Http.readyState == 4 && Http.status == 200)
			{
				var response = JSON.parse(Http.responseText);				
				var world = response.Response;
				var coord = xy(world.X, world.Y);
				map.flyTo(coord, 4);
			}
		}
	}

	function flyToCoordinate(map, x, y) { 
		$('input#x').val(x);
		$('input#y').val(y);
		var coord = xy(x, y);
		map.flyTo(coord, 14);
	}

	function flyToInput()
	{
		let x = $('input#x').val();
		let y = $('input#y').val();
		flyToCoordinate(map, x, y);
	}

</script>

</html>
